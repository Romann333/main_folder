pip install whell
pip install telebot
pip install pytelegrambotapi

import telebot
from telebot import types  


bot = telebot.Telebot(token)    # Получаем  токен из телеграмма, придумываем ему имя

@bot.massage_handler(content_type=('text'))             #Принимает любой текст, после писать функцию для реакции
def get_text(message):                                 # Агруменом всегда писать message
    bot.send_message(message.chat.id, 'Текст или функция, результат парсинга)   # Если отправить message.text, то вернется тоже сообщение, которое и отпправил
        .reply_to

@bot.massage_handler()
def button(message):
    markup = types.InlinekeybordMarkup(row_width=1)   # Создание кнопки внутри поля ответов, чтобы кнопки были по 1 в ряду.

@bot.message_handler(commands=['button']) # Команды пишутся через /start... Атрибутом может быть функция, которая обрабатывает входящие сообщения
                                            Нужно помнить что msg возвращает много полезной инфы, обращатся к ней через точку message.chat.id...
def button(message):
    markup = types.InlineKeyboardMarkup(row_width=2)   /   markup = types.ReplyKeyboardMarkup(resize_keyboard=True)  # подгоняет размер кнопок
    item = types.InlineKeyboardButton('Как дела?', callback_data='question_1') / item = types.KeyboardButton('Как дела?', callback_data='question_1')
    item2 = types.InlineKeyboardButton('Пока', callback_data='goodbye')
    markup.add(item, item2)   #добавление кнопок к панели!!!
 
    bot.send_message(message.chat.id, 'Привет!', reply_markup=markup)  # Бот отвечает текст и следом выводит подготовленные кнопки
 
    bot.send_message(message.chat.id,  'Привет!, {0.first_name}!'.format(message.from_user), reply_markup=markup)




@bot.callback_query_handler(func=lambda call:True)     # Декоратор для возврата действия после нажатия конкретной кнопки.
def callback(call):
    if call.message:
        if call.data == 'question_1':
            bot.edit_message_text(chat_id=call.message.chat.id, message_id=call.message.id, text= 'Дела отлично!')   # Полностью обрновляется поле вывода сообщений
        elif call.data == 'goodbye':
            bot.edit_message_text(chat_id=call.message.chat.id, message_id=call.message.id, text= 'Пока друг')                                                                                                                      









# Обработка нажатия кнопки
@bot.massage_handler(content_type=('text')) 
def get_text(message):
    if message.chat.type == 'privat':
        if message.text == 'Текст кнопки':
            выполняем какое то действие... и так добавление
        elif:

# Создание меню из кнопок после ввода стартовой команды старт
@bot.message_handler(commands=['start'])
def button(message):
    markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
    item = types.KeyboardButton('Как дела?', callback_data='question_1') # Создание кнопки, можно без колл бэка
    ...
    markup.add(item, item2)   #добавление кнопок к панели!!! Можно добавлять и кнопку 'back'
    bot.send_message(message.chat.id,  'Привет!, {0.first_name}!'.format(message.from_user), reply_markup=markup) # Кнопки появятся только после этого сообщения

 
# Постоянное ожидание сообщения с циклом тру.
while True:
    try:
        bot.polling(none_stop=True, interval=0)
    except Exception:
        time.sleep(15
        )
